# Online Book Store

- [Project Structure](#project-structure)
- [Local Setup](#local-setup)
  - [Dependencies](#dependencies)
  - [Generating `.env` File](#generating-env-file)
  - [Database](#database)
- [Commands](#commands)
  - [Migrate](#migrate)
  - [Backfill](#backfill)
  - [GORM Gen](#gorm-gen)
  - [Build and Run](#build-and-run)
  - [Testing](#testing)
    - [Mocks](#mocks)
  - [Swagger](#swagger)
- [Session Handling](#session-handling)

## Project Structure

- `cmd`
    - `app`: app's main.go here
    - `cli`: additional CLI scripts
- `conf`: configurations
- `docs`: swagger api docs
- `internal`
    - `api`: api implementations
    - `domain`: domain abstractions
    - `impl`: implementation of domain abstractions
    - `service`: business logic
- `migrations`: sql migrations (using golang-migrate standard)

## Local Setup

### Dependencies

This assumes you are using macos or linux.

Make sure you have these dependencies installed:
- `go` (1.20 or above)
- `make`
- `docker` (make sure you can execute `docker ps` without sudo)
- `migrate` (https://github.com/golang-migrate/migrate)
- `mockery` (https://github.com/vektra/mockery)

To check if these dependencies has been installed properly, after installing `make`, you can execute:
```bash
make doctor
```

### Generating `.env` File

To generate `.env` file, execute:
```bash
make env
```

### Database

To run the database, execute:
```bash
make compose
```

This will run `postgres` on `docker` by using `compose.yml`.

## Commands

### Migrate

To migrate the DB schema into `postgres`, execute this:
```bash
make migrate
```

### Backfill

To backfill the `books` table, execute this:
```bash
make backfill
```

This will generate 1000 random new books every time it's executed.

### GORM Gen

If there's any changes to the migration files (under `./migrations`), execute:
```bash
make gen
```
This will regenerate the models and query interfaces.

### Build and Run

To only build, execute:
```bash
make build
```

To build and run, execute:
```bash
make run
```

### Testing

To run unit tests, execute:
```bash
make test
```

#### Mocks

We're using `mockery` to generate mocks. All `mock_*.go` files are generated by `mockery` except for `mock_impl.go`.

### Swagger

If there's any changes to the APIs, you can re-generate the swagger docs by executing:
```bash
make swag
```

To access swagger, run the application and then go to http://localhost:8080/swagger. Make sure you have `SWAGGER_ENABLED=true` in `.env`.

## Session Handling

This implementation uses JWT as session token. This is solely for the purpose of simplifying the implementation so that I can focus on more important part of the implementation. In production, using JWT as session is not preferable as discussed here: https://curity.io/resources/learn/jwt-best-practices/#13-do-not-use-jwts-for-sessions

The preferable alternative would be generating a unique and ireversible session token that's stored somewhere in a datastore that can be revoked from the backend side at any time.